#!/usr/bin/env python2.7

import glob
import markdown
import re
import subprocess
import sys

### constants ###

TABS = '    '

BLOG_ENTRIES = '/home/menato/webapps/blog/entries'
BLOG_COMMON = '/home/menato/webapps/blog/common'
BLOG_TEMPLATES = '/home/menato/webapps/blog/templates/entries'

ARG_WT = '--work-tree=' + BLOG_ENTRIES
ARG_GD = '--git-dir=/home/menato/webapps/git/repos/blog.git'

md_converter = markdown.Markdown()
separator_re = re.compile('^===+ [A-Za-z]+ ===+$')
master_re = re.compile('.*/master$')
txt_re = re.compile('.+\.txt$')

### updated files parsing ###

def convert(text):
    html_head = '{% extends "base.html" %}\n\n'
    html_head += '{% block container %}\n'
    html_body = md_converter.reset().convert(text)
    html_tail = '\n{% endblock %}\n'

    return html_head + html_body + html_tail

def convert_and_parse(input_name, output_name):
    tags_num = 0
    header_num = 1
    summary_num = 2
    body_num  = 3

    lines = ['', '', '', '']

    current_num = -1

    input = open(input_name, 'r')

    for line in input:
        mode = ''
        if separator_re.match(line):
            mode = line[:-1].strip('= ').lower()

        if mode == 'tags':
            current_num = tags_num
        elif mode == 'header':
            current_num = header_num
        elif mode == 'summary':
            current_num = summary_num
        elif mode == 'body':
            current_num = body_num
        elif current_num >= 0:
            lines[current_num] += line

    output = open(output_name, 'w')
    output.write(convert(lines[body_num]))

    tags = filter(bool, lines[tags_num].translate(None, '\n').split(';'))
    header = lines[header_num][0:lines[header_num].find('\n')]

    return tags, header, lines[summary_num]

### updating ###

def update(names):

    for name in names:
        if not txt_re.match(name):
            continue

        txt_name = BLOG_ENTRIES + '/' + name
        html_name = BLOG_TEMPLATES + '/' + name[:-3] + 'html'
        tags_name = BLOG_ENTRIES + '/' + name[:-3] + 'tags'
        header_name = BLOG_ENTRIES + '/' + name[:-3] + 'header'
        summary_name = BLOG_ENTRIES + '/' + name[:-3] + 'summary'

        tags, header, summary = convert_and_parse(txt_name, html_name)

        if len(tags) > 0:
            tags_file = open(tags_name, 'w')
            for tag in tags:
                tags_file.write(tag.strip() + '\n')

        if len(header) > 0:
            header_file = open(header_name, 'w')
            header_file.write(header)

        if len(summary) > 0:
            summary_file = open(summary_name, 'w')
            summary_file.write(summary)

def collect_tags():
    tags_mask = BLOG_ENTRIES + '/*.tags'
    names = glob.glob(tags_mask)
    syntax_py_name = BLOG_COMMON + '/syntax_highlighter.py'
    syntax_py = open(syntax_py_name, 'w')
    syntax_py.write('brashes = {\n')

    for full_name in names:
        name = full_name[full_name.rfind('/') + 1:-5]
        brashes = []

        tags_file = open(full_name, 'r')
        for line in tags_file:
            tag = line.strip()
            if len(tag) == 0:
                continue

            if tag[:3] == 'sh ':
                brashes.append(tag[3:])

        if len(brashes) > 0:
            syntax_py.write(TABS + '"' + name + '": ' + str(brashes) + ',\n')

    syntax_py.write('}\n\ndef syntax_brashes(name):\n')
    syntax_py.write(TABS + 'if name in brashes:\n')
    syntax_py.write(TABS + TABS + 'return brashes[name]\n\n')
    syntax_py.write(TABS + 'return []\n')

### script ###

if __name__ == '__main__':

    for line in sys.stdin.xreadlines():
        old, new, ref = line.strip().split(' ')
        if not master_re.match(ref):
            print 'Ref ' + ref + ' received, but it is not a master.'
            continue

        print 'Ref ' + ref + ' received, deployed to production.'

        subprocess.call(['git', ARG_WT, ARG_GD, 'checkout', '-f'])
        p = subprocess.Popen(['git', ARG_GD, 'diff', '--name-only', old, new],
            stdout=subprocess.PIPE, stderr=subprocess.PIPE)

        out, err = p.communicate()

        update(out.strip().split('\n'))
        collect_tags()



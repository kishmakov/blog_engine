#!/usr/bin/env python2.7

import datetime
import glob
import markdown
import re
import subprocess
import sys

### constants ###

TABS = '    '

BLOG_ENTRIES = '/home/menato/webapps/blog/entries'
BLOG_COMMON = '/home/menato/webapps/blog/common'
BLOG_TEMPLATES = '/home/menato/webapps/blog/templates/entries'

ARG_WT = '--work-tree=' + BLOG_ENTRIES
ARG_GD = '--git-dir=/home/menato/webapps/git/repos/blog.git'

RESTART_CMD = '/home/menato/webapps/blog/apache2/bin/restart'

md_converter = markdown.Markdown()
separator_re = re.compile('^===+ [A-Za-z]+ ===+$')
master_re = re.compile('.*/master$')
txt_re = re.compile('.+\.txt$')

### tools ###

def relative_name(full_name):
    end = full_name.rfind('.')
    end = end if end > 0 else len(full_name)
    return full_name[full_name.rfind('/') + 1: end]

def info_names(name):
    pref = BLOG_ENTRIES + '/' + name + '.'
    return pref + 'tags', pref + 'header', pref + 'summary'

def normal_tag(tag):
    return tag[:7] != 'syntax '

### updated files parsing ###

def mathjaxify(text):
    subs = { '\\(': '\\\\(', '\\[': '\\\\[', '\\)': '\\\\)', '\\]': '\\\\]' }

    for k, v in subs.iteritems():
        text = text.replace(k, v)

    return text

def prepare_template(header, raw_text):
    html_head = '{% extends "entry_base.html" %}\n\n'
    html_head += '{% block container %}\n'
    text = '# ' + header + '\n' + mathjaxify(raw_text)
    html_body = md_converter.reset().convert(text)
    html_tail = '\n{% endblock %}\n'

    return html_head + html_body + html_tail

def convert_and_parse(input_name, output_name):
    tags_num = 0
    header_num = 1
    summary_num = 2
    body_num  = 3

    lines = ['', '', '', '']

    current_num = -1

    input = open(input_name, 'r')

    for line in input:
        mode = ''
        if separator_re.match(line):
            mode = line[:-1].strip('= ').lower()

        if mode == 'tags':
            current_num = tags_num
        elif mode == 'header':
            current_num = header_num
        elif mode == 'summary':
            current_num = summary_num
        elif mode == 'body':
            current_num = body_num
        elif current_num >= 0:
            lines[current_num] += line

    header = lines[header_num][0:lines[header_num].find('\n')]

    if len(header) == 0:
        name = relative_name(input_name)
        name_words = [s.capitalize() for s in name.split('_')]
        header = ' '.join(name_words[1:])

    output = open(output_name, 'w')
    output.write(prepare_template(header, lines[body_num]))

    tags = filter(bool, lines[tags_num].translate(None, '\n').split(';'))

    return tags, header, lines[summary_num]

### updating ###

def update(names):
    update_time = "{:%Y-%m-%d @ %H:%M}".format(datetime.datetime.now())

    for name in names:
        if not txt_re.match(name):
            continue

        txt_name = BLOG_ENTRIES + '/' + name
        html_name = BLOG_TEMPLATES + '/' + name[:-3] + 'html'
        tags_name, header_name, summary_name = info_names(name[:-4])
        tags, header, summary = convert_and_parse(txt_name, html_name)

        if len(tags) > 0:
            tags_file = open(tags_name, 'w')
            for tag in tags:
                tags_file.write(tag.strip() + '\n')

        if len(summary) > 0:
            summary_file = open(summary_name, 'w')
            summary_file.write(summary)

        header_file = open(header_name, 'w')
        header_file.write(header + '\n')
        header_file.write(update_time + '\n')

def write_entry_tools(descriptions):
    file_py_name = BLOG_COMMON + '/entry_tools.py'
    file_py = open(file_py_name, 'w')
    file_py.write('descriptions = {\n')

    for description in descriptions:
        id = description['id']
        header = description['header']
        updated = description['updated']
        summary = description['summary']
        ntags = description['navi_tags']
        stags = description['syntax_tags']
        file_py.write(TABS + repr(id) + ': {\n')
        file_py.write(TABS + TABS + "'id': " + repr(id) + ',\n')
        file_py.write(TABS + TABS + "'header': " + repr(header) + ',\n')
        file_py.write(TABS + TABS + "'updated': " + repr(updated) + ',\n')

        file_py.write(TABS + TABS + "'summary': [");
        for line in summary:
            file_py.write(repr(line.strip()) + ',')
        file_py.write('],\n')

        file_py.write(TABS + TABS + "'tags': " + str(sorted(ntags)) + ',\n')
        file_py.write(TABS + TABS + "'brashes': " + str(stags) + ',\n')
        file_py.write(TABS + '},\n')

    file_py.write('}\n')

def write_list_tools(descriptions):
    file_py_name = BLOG_COMMON + '/list_tools.py'
    file_py = open(file_py_name, 'w')
    file_py.write('search_ids = [\n')

    id2num = {}
    tag2ids = {}

    description_id = 0

    for description in descriptions:
        file_py.write(TABS + repr(description['id']) + ',\n')

        id2num[description['id']] = description_id
        description_id += 1

        for tag in description['navi_tags']:
            if tag not in tag2ids:
                tag2ids[tag] = []

            tag2ids[tag].append(description['id'])

    file_py.write(']\n\nsearch_tags = {\n')

    for tag in sorted(tag2ids):
        ids = tag2ids[tag]
        file_py.write(TABS + repr(tag) + ': [')

        counter = 0
        for id in ids:
            counter += 1
            if counter > 20:
                counter = 0
                file_py.write('\n' + TABS + TABS)

            file_py.write(str(id2num[id]) + ', ')

        file_py.write('],\n')

    file_py.write('}\n')

def classify_tags(file_name):
    navi_tags = []
    syntax_tags = []

    try:
        tags_file = open(file_name, 'r')
        for line in tags_file:
            tag = line.strip()
            if len(tag) == 0:
                continue

            if not normal_tag(tag):
                syntax_tags.append(tag[7:])
            else:
                navi_tags.append(tag)
    except:
        pass

    return navi_tags, syntax_tags

def collect_descriptions():
    descriptions = []
    for full_name in sorted(glob.glob(BLOG_ENTRIES + '/*.txt'), reverse=True):
        name = relative_name(full_name)
        tags_name, header_name, summary_name = info_names(name)
        description = { 'id': name, 'summary': ''}

        description['navi_tags'], description['syntax_tags'] = classify_tags(tags_name)

        try:
            header_file = open(header_name, 'r')
            description['header'] = header_file.readline().strip()
            description['updated'] = header_file.readline().strip()
        except:
            pass

        try:
            summary_file = open(summary_name, 'r')
            lines = ''
            for line in summary_file:
                lines += line
            description['summary'] = lines.split('\n\n')
        except:
            pass

        descriptions.append(description)

    write_entry_tools(descriptions)
    write_list_tools(descriptions)

### script ###

if __name__ == '__main__':

    for line in sys.stdin.xreadlines():
        old, new, ref = line.strip().split(' ')
        if not master_re.match(ref):
            print 'Ref ' + ref + ' received, but it is not "master".'
            continue

        print 'Ref ' + ref + ' received, deployed to production.'

        subprocess.call(['git', ARG_WT, ARG_GD, 'checkout', '-f'])
        p = subprocess.Popen(['git', ARG_GD, 'diff', '--name-only', old, new],
            stdout=subprocess.PIPE, stderr=subprocess.PIPE)

        out, err = p.communicate()
        update(out.strip().split('\n'))
        collect_descriptions()
        subprocess.call([RESTART_CMD])



#!/usr/bin/env python2.7

import datetime
import glob
import markdown
import re
import subprocess
import sys

### constants ###

TABS = '    '

BLOG_ENTRIES = '/home/menato/webapps/blog/entries'
BLOG_COMMON = '/home/menato/webapps/blog/common'
BLOG_TEMPLATES = '/home/menato/webapps/blog/templates/entries'

ARG_WT = '--work-tree=' + BLOG_ENTRIES
ARG_GD = '--git-dir=/home/menato/webapps/git/repos/blog.git'

RESTART_CMD = '/home/menato/webapps/blog/apache2/bin/restart'

md_converter = markdown.Markdown()
separator_re = re.compile('^===+ [A-Za-z]+ ===+$')
master_re = re.compile('.*/master$')
txt_re = re.compile('.+\.txt$')

### tools ###

def relative_name(full_name):
    end = full_name.rfind('.')
    end = end if end > 0 else len(full_name)
    return full_name[full_name.rfind('/') + 1: end]

def info_names(name):
    pref = BLOG_ENTRIES + '/' + name + '.'
    return pref + 'tags', pref + 'header', pref + 'summary'

def normal_tag(tag):
    return tag[:7] != 'syntax '

### updated files parsing ###

def convert(text):
    html_head = '{% extends "entry_base.html" %}\n\n'
    html_head += '{% block container %}\n'
    html_body = md_converter.reset().convert(text)
    html_tail = '\n{% endblock %}\n'

    return html_head + html_body + html_tail

def convert_and_parse(input_name, output_name):
    tags_num = 0
    header_num = 1
    summary_num = 2
    body_num  = 3

    lines = ['', '', '', '']

    current_num = -1

    input = open(input_name, 'r')

    for line in input:
        mode = ''
        if separator_re.match(line):
            mode = line[:-1].strip('= ').lower()

        if mode == 'tags':
            current_num = tags_num
        elif mode == 'header':
            current_num = header_num
        elif mode == 'summary':
            current_num = summary_num
        elif mode == 'body':
            current_num = body_num
        elif current_num >= 0:
            lines[current_num] += line

    output = open(output_name, 'w')
    output.write(convert(lines[body_num]))

    tags = filter(bool, lines[tags_num].translate(None, '\n').split(';'))
    header = lines[header_num][0:lines[header_num].find('\n')]

    return tags, header, lines[summary_num]

### updating ###

def update(names):
    update_time = "{:%Y-%m-%d @ %H:%M}".format(datetime.datetime.now())

    for name in names:
        if not txt_re.match(name):
            continue

        txt_name = BLOG_ENTRIES + '/' + name
        html_name = BLOG_TEMPLATES + '/' + name[:-3] + 'html'
        tags_name, header_name, summary_name = info_names(name[:-4])
        tags, header, summary = convert_and_parse(txt_name, html_name)

        if len(tags) > 0:
            tags_file = open(tags_name, 'w')
            for tag in tags:
                tags_file.write(tag.strip() + '\n')

        if len(summary) > 0:
            summary_file = open(summary_name, 'w')
            summary_file.write(summary)

        if len(header) == 0:
            header_words = [s.capitalize() for s in name[:-4].split('_')]
            header = ' '.join(header_words[1:])

        header_file = open(header_name, 'w')
        header_file.write(header + '\n')
        header_file.write(update_time + '\n')

def classify_tags(file_name):
    tags = []
    brashes = []

    tags_file = open(file_name, 'r')
    for line in tags_file:
        tag = line.strip()
        if len(tag) == 0:
            continue

        if not normal_tag(tag):
            brashes.append(tag[7:])
        else:
            tags.append(tag)

    return tags, brashes

def write_syntax_highlighter(all_brashes):
    syntax_py_name = BLOG_COMMON + '/syntax_highlighter.py'
    syntax_py = open(syntax_py_name, 'w')
    syntax_py.write('brashes = {\n')

    for name, brashes in all_brashes.iteritems():
        if len(brashes) > 0:
            syntax_py.write(TABS + repr(name) + ': ' + str(brashes) + ',\n')

    syntax_py.write('}\n\ndef syntax_brashes(name):\n')
    syntax_py.write(TABS + 'return brashes[name] if name in brashes else []\n')


def collect_tags():
    tags = {}
    brashes = {}

    for full_name in glob.glob(BLOG_ENTRIES + '/*.tags'):
        name = relative_name(full_name)
        tags[name], brashes[name] = classify_tags(full_name)

    write_syntax_highlighter(brashes)

def write_descriptions(descriptions):
    file_py_name = BLOG_COMMON + '/descriptions.py'
    file_py = open(file_py_name, 'w')
    file_py.write('descriptions = {\n')

    for description in descriptions:
        id = description['id']
        header = description['header']
        updated = description['updated']
        summary = description['summary']
        tags = filter(normal_tag, description['tags'])
        file_py.write(TABS + repr(id) + ': {\n')
        file_py.write(TABS + TABS + "'id': " + repr(id) + ',\n')
        file_py.write(TABS + TABS + "'header': " + repr(header) + ',\n')
        file_py.write(TABS + TABS + "'updated': " + repr(updated) + ',\n')
        file_py.write(TABS + TABS + "'summary': " + repr(summary) + ',\n')
        file_py.write(TABS + TABS + "'tags': " + str(tags) + ',\n')
        file_py.write(TABS + '},\n')

    file_py.write('}\n')

def write_search_tools(descriptions):
    file_py_name = BLOG_COMMON + '/search_tools.py'
    file_py = open(file_py_name, 'w')
    file_py.write('search_ids = [\n')

    id2num = {}
    tag2ids = {}

    description_id = 0

    for description in descriptions:
        file_py.write(TABS + repr(description['id']) + ',\n')

        id2num[description['id']] = description_id
        description_id += 1

        for tag in description['tags']:
            if not normal_tag(tag):
                continue

            if tag not in tag2ids:
                tag2ids[tag] = []

            tag2ids[tag].append(description['id'])

    file_py.write(']\n\nsearch_tags = {\n')

    for tag, ids in tag2ids.iteritems():
        file_py.write(TABS + repr(tag.replace(' ', '_')) + ': [')

        counter = 0
        for id in ids:
            counter += 1
            if counter > 20:
                counter = 0
                file_py.write('\n' + TABS + TABS)

            file_py.write(str(id2num[id]) + ', ')

        file_py.write('],\n')

    file_py.write('}\n')

def collect_descriptions():
    descriptions = []
    for full_name in glob.glob(BLOG_ENTRIES + '/*.txt'):
        name = relative_name(full_name)
        tags_name, header_name, summary_name = info_names(name)
        description = { 'id': name, 'tags': [], 'summary': ''}

        try:
            tags_file = open(tags_name, 'r')
            for line in tags_file:
                tag = line.strip()
                if len(tag) > 0:
                    description['tags'].append(tag)
        except:
            pass

        try:
            header_file = open(header_name, 'r')
            description['header'] = header_file.readline().strip()
            description['updated'] = header_file.readline().strip()
        except:
            pass

        try:
            summary_file = open(summary_name, 'r')
            for line in summary_file:
                if len(line) > 1:
                    description['summary'] += line
        except:
            pass

        descriptions.append(description)

    write_descriptions(descriptions)
    write_search_tools(descriptions)

### script ###

if __name__ == '__main__':

    for line in sys.stdin.xreadlines():
        old, new, ref = line.strip().split(' ')
        if not master_re.match(ref):
            print 'Ref ' + ref + ' received, but it is not a master.'
            continue

        print 'Ref ' + ref + ' received, deployed to production.'

        subprocess.call(['git', ARG_WT, ARG_GD, 'checkout', '-f'])
        p = subprocess.Popen(['git', ARG_GD, 'diff', '--name-only', old, new],
            stdout=subprocess.PIPE, stderr=subprocess.PIPE)

        out, err = p.communicate()

        update(out.strip().split('\n'))

        collect_tags()
        collect_descriptions()

        subprocess.call([RESTART_CMD])


